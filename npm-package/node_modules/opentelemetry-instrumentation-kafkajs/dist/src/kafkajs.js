"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KafkaJsInstrumentation = void 0;
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const version_1 = require("./version");
const propagtor_1 = require("./propagtor");
const instrumentation_1 = require("@opentelemetry/instrumentation");
class KafkaJsInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
        super('opentelemetry-instrumentation-kafkajs', version_1.VERSION, Object.assign({}, config));
    }
    setConfig(config = {}) {
        this._config = Object.assign({}, config);
    }
    init() {
        const module = new instrumentation_1.InstrumentationNodeModuleDefinition(KafkaJsInstrumentation.component, ['*'], this.patch.bind(this), this.unpatch.bind(this));
        module.includePrerelease = true;
        return module;
    }
    patch(moduleExports, moduleVersion) {
        var _a, _b;
        api_1.diag.debug('kafkajs instrumentation: applying patch');
        this.moduleVersion = moduleVersion;
        this.unpatch(moduleExports);
        this._wrap((_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Kafka) === null || _a === void 0 ? void 0 : _a.prototype, 'producer', this._getProducerPatch.bind(this));
        this._wrap((_b = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Kafka) === null || _b === void 0 ? void 0 : _b.prototype, 'consumer', this._getConsumerPatch.bind(this));
        return moduleExports;
    }
    unpatch(moduleExports) {
        var _a, _b;
        api_1.diag.debug('kafkajs instrumentation: un-patching');
        if (instrumentation_1.isWrapped((_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Kafka) === null || _a === void 0 ? void 0 : _a.prototype.producer)) {
            this._unwrap(moduleExports.Kafka.prototype, 'producer');
        }
        if (instrumentation_1.isWrapped((_b = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Kafka) === null || _b === void 0 ? void 0 : _b.prototype.consumer)) {
            this._unwrap(moduleExports.Kafka.prototype, 'consumer');
        }
    }
    _getConsumerPatch(original) {
        const self = this;
        return function (...args) {
            const newConsumer = original.apply(this, arguments);
            if (instrumentation_1.isWrapped(newConsumer.run)) {
                self._unwrap(newConsumer, 'run');
            }
            self._wrap(newConsumer, 'run', self._getConsumerRunPatch.bind(self));
            return newConsumer;
        };
    }
    _getProducerPatch(original) {
        const self = this;
        return function (...args) {
            const newProducer = original.apply(this, arguments);
            if (instrumentation_1.isWrapped(newProducer.sendBatch)) {
                self._unwrap(newProducer, 'sendBatch');
            }
            self._wrap(newProducer, 'sendBatch', self._getProducerSendBatchPatch.bind(self));
            if (instrumentation_1.isWrapped(newProducer.send)) {
                self._unwrap(newProducer, 'send');
            }
            self._wrap(newProducer, 'send', self._getProducerSendPatch.bind(self));
            return newProducer;
        };
    }
    _getConsumerRunPatch(original) {
        const self = this;
        return function (config) {
            if (config === null || config === void 0 ? void 0 : config.eachMessage) {
                if (instrumentation_1.isWrapped(config.eachMessage)) {
                    self._unwrap(config, 'eachMessage');
                }
                self._wrap(config, 'eachMessage', self._getConsumerEachMessagePatch.bind(self));
            }
            if (config === null || config === void 0 ? void 0 : config.eachBatch) {
                if (instrumentation_1.isWrapped(config.eachBatch)) {
                    self._unwrap(config, 'eachBatch');
                }
                self._wrap(config, 'eachBatch', self._getConsumerEachBatchPatch.bind(self));
            }
            return original.call(this, config);
        };
    }
    _getConsumerEachMessagePatch(original) {
        const self = this;
        return function (payload) {
            const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, payload.message.headers, propagtor_1.bufferTextMapGetter);
            const span = self._startConsumerSpan(payload.topic, payload.message, semantic_conventions_1.MessagingOperationValues.PROCESS, propagatedContext);
            const eachMessagePromise = api_1.context.with(api_1.trace.setSpan(propagatedContext, span), () => {
                return original.apply(this, arguments);
            });
            return self._endSpansOnPromise([span], eachMessagePromise);
        };
    }
    _getConsumerEachBatchPatch(original) {
        const self = this;
        return function (payload) {
            // https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md#topic-with-multiple-consumers
            const receivingSpan = self._startConsumerSpan(payload.batch.topic, undefined, semantic_conventions_1.MessagingOperationValues.RECEIVE, api_1.ROOT_CONTEXT);
            return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), receivingSpan), () => {
                const spans = payload.batch.messages.map((message) => {
                    var _a;
                    const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, message.headers, propagtor_1.bufferTextMapGetter);
                    const spanContext = (_a = api_1.trace.getSpan(propagatedContext)) === null || _a === void 0 ? void 0 : _a.spanContext();
                    let origSpanLink;
                    if (spanContext) {
                        origSpanLink = {
                            context: spanContext,
                        };
                    }
                    return self._startConsumerSpan(payload.batch.topic, message, semantic_conventions_1.MessagingOperationValues.PROCESS, undefined, origSpanLink);
                });
                const batchMessagePromise = original.apply(this, arguments);
                spans.unshift(receivingSpan);
                return self._endSpansOnPromise(spans, batchMessagePromise);
            });
        };
    }
    _getProducerSendBatchPatch(original) {
        const self = this;
        return function (batch) {
            const spans = batch.topicMessages
                .map((topicMessage) => topicMessage.messages.map((message) => self._startProducerSpan(topicMessage.topic, message)))
                .reduce((acc, val) => acc.concat(val), []);
            const origSendResult = original.apply(this, arguments);
            return self._endSpansOnPromise(spans, origSendResult);
        };
    }
    _getProducerSendPatch(original) {
        const self = this;
        return function (record) {
            const spans = record.messages.map((message) => {
                return self._startProducerSpan(record.topic, message);
            });
            const origSendResult = original.apply(this, arguments);
            return self._endSpansOnPromise(spans, origSendResult);
        };
    }
    _endSpansOnPromise(spans, sendPromise) {
        return Promise.resolve(sendPromise)
            .catch((reason) => {
            let errorMessage;
            if (typeof reason === 'string')
                errorMessage = reason;
            else if (typeof reason === 'object' && reason.hasOwnProperty('message'))
                errorMessage = reason.message;
            spans.forEach((span) => span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: errorMessage,
            }));
            throw reason;
        })
            .finally(() => {
            spans.forEach((span) => span.end());
        });
    }
    _startConsumerSpan(topic, message, operation, context, link) {
        var _a;
        const span = this.tracer.startSpan(topic, {
            kind: api_1.SpanKind.CONSUMER,
            attributes: {
                [semantic_conventions_1.SemanticAttributes.MESSAGING_SYSTEM]: 'kafka',
                [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION]: topic,
                [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MessagingDestinationKindValues.TOPIC,
                [semantic_conventions_1.SemanticAttributes.MESSAGING_OPERATION]: operation,
            },
            links: link ? [link] : [],
        }, context);
        if (this._config.moduleVersionAttributeName) {
            span.setAttribute(this._config.moduleVersionAttributeName, this.moduleVersion);
        }
        if (((_a = this._config) === null || _a === void 0 ? void 0 : _a.consumerHook) && message) {
            instrumentation_1.safeExecuteInTheMiddle(() => this._config.consumerHook(span, topic, message), (e) => {
                if (e)
                    api_1.diag.error(`kafkajs instrumentation: consumerHook error`, e);
            }, true);
        }
        return span;
    }
    _startProducerSpan(topic, message) {
        var _a, _b;
        const span = this.tracer.startSpan(topic, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [semantic_conventions_1.SemanticAttributes.MESSAGING_SYSTEM]: 'kafka',
                [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION]: topic,
                [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MessagingDestinationKindValues.TOPIC,
            },
        });
        if (this._config.moduleVersionAttributeName) {
            span.setAttribute(this._config.moduleVersionAttributeName, this.moduleVersion);
        }
        message.headers = (_a = message.headers) !== null && _a !== void 0 ? _a : {};
        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), message.headers);
        if ((_b = this._config) === null || _b === void 0 ? void 0 : _b.producerHook) {
            instrumentation_1.safeExecuteInTheMiddle(() => this._config.producerHook(span, topic, message), (e) => {
                if (e)
                    api_1.diag.error(`kafkajs instrumentation: producerHook error`, e);
            }, true);
        }
        return span;
    }
}
exports.KafkaJsInstrumentation = KafkaJsInstrumentation;
KafkaJsInstrumentation.component = 'kafkajs';
//# sourceMappingURL=kafkajs.js.map