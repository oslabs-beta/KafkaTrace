{"version":3,"file":"ObservableRegistry.js","sourceRoot":"","sources":["../../../src/state/ObservableRegistry.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  diag,\n  HrTime,\n  BatchObservableCallback,\n  Observable,\n  ObservableCallback,\n} from '@opentelemetry/api';\nimport { isObservableInstrument, ObservableInstrument } from '../Instruments';\nimport {\n  BatchObservableResultImpl,\n  ObservableResultImpl,\n} from '../ObservableResult';\nimport {\n  callWithTimeout,\n  PromiseAllSettled,\n  isPromiseAllSettledRejectionResult,\n  setEquals,\n} from '../utils';\n\n/**\n * Records for single instrument observable callback.\n */\ninterface ObservableCallbackRecord {\n  callback: ObservableCallback;\n  instrument: ObservableInstrument;\n}\n\n/**\n * Records for multiple instruments observable callback.\n */\ninterface BatchObservableCallbackRecord {\n  callback: BatchObservableCallback;\n  instruments: Set<ObservableInstrument>;\n}\n\n/**\n * An internal interface for managing ObservableCallbacks.\n *\n * Every registered callback associated with a set of instruments are be evaluated\n * exactly once during collection prior to reading data for that instrument.\n */\nexport class ObservableRegistry {\n  private _callbacks: ObservableCallbackRecord[] = [];\n  private _batchCallbacks: BatchObservableCallbackRecord[] = [];\n\n  addCallback(callback: ObservableCallback, instrument: ObservableInstrument) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx >= 0) {\n      return;\n    }\n    this._callbacks.push({ callback, instrument });\n  }\n\n  removeCallback(\n    callback: ObservableCallback,\n    instrument: ObservableInstrument\n  ) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx < 0) {\n      return;\n    }\n    this._callbacks.splice(idx, 1);\n  }\n\n  addBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Observable[]\n  ) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(\n      instruments.filter(isObservableInstrument)\n    );\n    if (observableInstruments.size === 0) {\n      diag.error(\n        'BatchObservableCallback is not associated with valid instruments',\n        instruments\n      );\n      return;\n    }\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx >= 0) {\n      return;\n    }\n    this._batchCallbacks.push({ callback, instruments: observableInstruments });\n  }\n\n  removeBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Observable[]\n  ) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(\n      instruments.filter(isObservableInstrument)\n    );\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx < 0) {\n      return;\n    }\n    this._batchCallbacks.splice(idx, 1);\n  }\n\n  /**\n   * @returns a promise of rejected reasons for invoking callbacks.\n   */\n  async observe(\n    collectionTime: HrTime,\n    timeoutMillis?: number\n  ): Promise<unknown[]> {\n    const callbackFutures = this._observeCallbacks(\n      collectionTime,\n      timeoutMillis\n    );\n    const batchCallbackFutures = this._observeBatchCallbacks(\n      collectionTime,\n      timeoutMillis\n    );\n\n    const results = await PromiseAllSettled([\n      ...callbackFutures,\n      ...batchCallbackFutures,\n    ]);\n\n    const rejections = results\n      .filter(isPromiseAllSettledRejectionResult)\n      .map(it => it.reason);\n    return rejections;\n  }\n\n  private _observeCallbacks(observationTime: HrTime, timeoutMillis?: number) {\n    return this._callbacks.map(async ({ callback, instrument }) => {\n      const observableResult = new ObservableResultImpl(instrument._descriptor);\n      let callPromise: Promise<void> = Promise.resolve(\n        callback(observableResult)\n      );\n      if (timeoutMillis != null) {\n        callPromise = callWithTimeout(callPromise, timeoutMillis);\n      }\n      await callPromise;\n      instrument._metricStorages.forEach(metricStorage => {\n        metricStorage.record(observableResult._buffer, observationTime);\n      });\n    });\n  }\n\n  private _observeBatchCallbacks(\n    observationTime: HrTime,\n    timeoutMillis?: number\n  ) {\n    return this._batchCallbacks.map(async ({ callback, instruments }) => {\n      const observableResult = new BatchObservableResultImpl();\n      let callPromise: Promise<void> = Promise.resolve(\n        callback(observableResult)\n      );\n      if (timeoutMillis != null) {\n        callPromise = callWithTimeout(callPromise, timeoutMillis);\n      }\n      await callPromise;\n      instruments.forEach(instrument => {\n        const buffer = observableResult._buffer.get(instrument);\n        if (buffer == null) {\n          return;\n        }\n        instrument._metricStorages.forEach(metricStorage => {\n          metricStorage.record(buffer, observationTime);\n        });\n      });\n    });\n  }\n\n  private _findCallback(\n    callback: ObservableCallback,\n    instrument: ObservableInstrument\n  ) {\n    return this._callbacks.findIndex(record => {\n      return record.callback === callback && record.instrument === instrument;\n    });\n  }\n\n  private _findBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Set<ObservableInstrument>\n  ) {\n    return this._batchCallbacks.findIndex(record => {\n      return (\n        record.callback === callback &&\n        setEquals(record.instruments, instruments)\n      );\n    });\n  }\n}\n"]}